<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><link rel="stylesheet" type="text/less" href="../stylesheets/less/default.less"/><script type="text/javascript" src="../javascripts/less-1.3.0.min.js"></script>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1504.83">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 22.0px 'Hiragino Kaku Gothic Pro'}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; min-height: 18.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 17.0px 'Hiragino Kaku Gothic Pro'}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #d4d4d4; background-color: #232323}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #dcdcaa; background-color: #232323}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #608b4e; background-color: #232323}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #d4d4d4; background-color: #232323; min-height: 18.0px}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #c586c0; background-color: #232323}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #ce9178; background-color: #232323}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #000000; min-height: 18.0px}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #000000}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 17.0px 'Hiragino Kaku Gothic Pro'; color: #000000}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333; background-color: #fefefe; min-height: 18.0px}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333; background-color: #fefefe}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #000000; background-color: #ffffff}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #000000; background-color: #ffffff; min-height: 18.0px}
    p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px Menlo; color: #ffffff; -webkit-text-stroke: #d4d4d4; background-color: #232323}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px Menlo; color: #ffffff; -webkit-text-stroke: #d4d4d4; background-color: #232323; min-height: 14.0px}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px Menlo; color: #ffffff; -webkit-text-stroke: #ce9178; background-color: #232323}
    p.p22 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px Menlo; color: #d4d4d4; -webkit-text-stroke: #d4d4d4; min-height: 14.0px}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333; -webkit-text-stroke: #d4d4d4}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333; -webkit-text-stroke: #d4d4d4; background-color: #fefefe}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 18.0px; font: 12.0px 'Hiragino Kaku Gothic Pro'; color: #333333; -webkit-text-stroke: #d4d4d4; background-color: #fefefe; min-height: 18.0px}
    span.s1 {font-kerning: none}
    span.s2 {font-kerning: none; color: #d4d4d4}
    span.s3 {font-kerning: none; color: #9cdcfe}
    span.s4 {font-kerning: none; color: #dcdcaa}
    span.s5 {font-kerning: none; color: #ce9178}
    span.s6 {font-kerning: none; color: #b5cea8}
    span.s7 {font-kerning: none; color: #c586c0}
    span.s8 {font-kerning: none; color: #569cd6}
    span.s9 {font-kerning: none; color: #608b4e}
    span.s10 {color: #000000}
    span.s11 {font-variant-ligatures: no-common-ligatures; background-color: #ffffff}
    span.s12 {font-kerning: none; background-color: #fefefe}
    span.s13 {font-kerning: none; color: #333333; background-color: #fefefe}
    span.s14 {font-variant-ligatures: no-common-ligatures}
    span.s15 {font-variant-ligatures: no-common-ligatures; color: #000000; background-color: #ffffff}
    span.s16 {font-kerning: none; -webkit-text-stroke: 0px #ce9178}
    span.s17 {font-kerning: none; -webkit-text-stroke: 0px #b5cea8}
    span.s18 {font-kerning: none; -webkit-text-stroke: 0px #d4d4d4}
    span.s19 {font: 12.0px Menlo; font-kerning: none; color: #d4d4d4}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>qdanshitaのチューニング紹介</b></p>
<p class="p2"><br></p>
<p class="p3"><b>概要</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx-luajit-websocket-udp、略してqdanshitaになった。</p>
<p class="p3"><span class="Apple-tab-span">	</span>各機構の設定の関連性や、ログ、チューニングについて書く。</p>
<p class="p3"><span class="Apple-tab-span">	</span>あとベンチマーク用にlocustスクリプトを用意したので、それについても書く。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>リポジトリはここ。</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><a href="https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore">https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore</a></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p3"><b>機構構成</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx + lua(micro websocket server per connection)、</p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx stream + go-udp-server(udp receiver/sender)</p>
<p class="p3"><span class="Apple-tab-span">	</span>disque(upstream/downstream message queue) を組み合わせた機構。</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>特性</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>・1ユーザーにつき、消費するポートはユーザ接続tcp1つ + disque-nginx up/down tcp2 の3つ。</p>
<p class="p3"><span class="Apple-tab-span">	</span>・queueを挟むため、負荷に強い。</p>
<p class="p3"><span class="Apple-tab-span">	</span>・upstream(上流サーバ)を完全非同期に実装できる。この仕組みは、ゲームロジックをbackpressureの負荷を考えずに実行するのに役立つ。</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>接続とデータフロー</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>0.マッチング、接続に必要なパラメータを取得</p>
<p class="p3"><span class="Apple-tab-span">	</span>1.クライアントとの間にudpでのデータ送付経路を確立</p>
<p class="p3"><span class="Apple-tab-span">	</span>2. 0,1で取得したパラメータを使って、websocketでの接続を行う。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>udp接続の手順はスキップすることができ、その場合downstreamでのudp送付は発生しなくなる。(要luaカスタマイズ)</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>接続後、udp、wsを介してdownstreamのデータがサーバからクライアントへと送付される。</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>nginx.conf、lua、go-udp-server、disqueのセッティング</b></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p3"><b>nginx.conf</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx.conf(<a href="https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/nginx.conf">https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/nginx.conf</a>)</p>
<p class="p3"><span class="Apple-tab-span">	</span>workerごとの接続数などを設定する。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx streamで8080ポートで受け止めたudpを8081ポートで待つgo-udp-serverへとproxyしている。</p>
<p class="p2"><b></b><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>urlに対してluaファイルのパスを指定、ルーティングを行う。</p>
<p class="p3"><span class="Apple-tab-span">	</span>サンプルでは、次のような記述で、http://SOMEWHERE/sample_disque_client へと到達したリクエストを、sample_disque_client.luaスクリプトへと転送する。</p>
<p class="p5"><span class="s1"># sample disque client route.</span></p>
<p class="p6"><span class="s2">location /</span><span class="s1">sample_disque_client</span><span class="s2"> {</span></p>
<p class="p5"><span class="s1"><span class="Apple-converted-space">    </span>content_by_lua_file lua/sample_disque_client.</span><span class="s3">lua</span><span class="s1">;</span></p>
<p class="p5"><span class="s1">}</span></p>
<p class="p2"><br></p>
<p class="p2"><b></b><br></p>
<p class="p2"><b></b><br></p>
<p class="p3"><b>lua</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>/luaフォルダ以下に入っている。</p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx.confのルーティングから呼ばれ、リクエスト時に実行される。</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p3"><span class="Apple-tab-span">	</span>セッティング、リクエストヘッダ値の読み出し/分岐、そのパラメータを使った認証機構を入れる箇所がある。</p>
<p class="p3"><span class="Apple-tab-span">	</span>また、upstreamが <b>リクエストurl末尾path + _context</b> というqueue名でdisqueからデータを引き出せるようになっている。</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span></b>sample_disque_client.lua(<a href="https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/lua/sample_disque_client.lua">https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/lua/sample_disque_client.lua</a>)</p>
<p class="p7"><span class="s1">-- get identity of game from url. e.g. http://somewhere/game_key -&gt; game_key_context.</span></p>
<p class="p5"><span class="s1">UPSTREAM_IDENTIFIER = </span><span class="s4">string.gsub</span><span class="s1">(ngx.</span><span class="s3">var</span><span class="s1">.</span><span class="s3">uri</span><span class="s1">, </span><span class="s5">"/"</span><span class="s1">, </span><span class="s5">""</span><span class="s1">) .. </span><span class="s5">"_context"</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- message type definitions.</span></p>
<p class="p5"><span class="s1">STATE_CONNECT <span class="Apple-converted-space">          </span>= </span><span class="s6">1</span></p>
<p class="p5"><span class="s1">STATE_STRING_MESSAGE<span class="Apple-converted-space">    </span>= </span><span class="s6">2</span></p>
<p class="p5"><span class="s1">STATE_BINARY_MESSAGE<span class="Apple-converted-space">    </span>= </span><span class="s6">3</span></p>
<p class="p5"><span class="s1">STATE_DISCONNECT_INTENT = </span><span class="s6">4</span></p>
<p class="p5"><span class="s1">STATE_DISCONNECT_ACCIDT = </span><span class="s6">5</span></p>
<p class="p5"><span class="s1">STATE_DISCONNECT_DISQUE_ACKFAILED = </span><span class="s6">6</span></p>
<p class="p5"><span class="s1">STATE_DISCONNECT_DISQUE_ACCIDT_SENDFAILED = </span><span class="s6">7</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">---- SETTINGS ----</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- upstream/downstream queue.</span></p>
<p class="p5"><span class="s1">DISQUE_IP = </span><span class="s5">"127.0.0.1"</span></p>
<p class="p5"><span class="s1">DISQUE_PORT = </span><span class="s6">7711</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- CONNECTION_ID is nginx's request id. that len is 32. guidv4 length is 36, add four "0".<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">-- overwritten by token.</span></p>
<p class="p5"><span class="s1">CONNECTION_ID = ngx.</span><span class="s3">var</span><span class="s1">.</span><span class="s3">request_id</span><span class="s1"> .. </span><span class="s5">"0000"</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- go unix domain socket path.</span></p>
<p class="p5"><span class="s1">UNIX_DOMAIN_SOCKET_PATH = </span><span class="s5">"unix:/tmp/go-udp-server"</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- max size of downstream message.</span></p>
<p class="p5"><span class="s1">DOWNSTREAM_MAX_PAYLOAD_LEN = </span><span class="s6">1024</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">---- REQUEST HEADER PARAMS ----</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p5"><span class="s7">local</span><span class="s1"> token = ngx.</span><span class="s3">req</span><span class="s1">.</span><span class="s4">get_headers</span><span class="s1">()[</span><span class="s5">"token"</span><span class="s1">]</span></p>
<p class="p5"><span class="s7">if</span><span class="s1"> not token </span><span class="s7">then</span></p>
<p class="p5"><span class="s1">    ngx.</span><span class="s4">log</span><span class="s1">(ngx.</span><span class="s3">ERR</span><span class="s1">, </span><span class="s5">"no token."</span><span class="s1">)</span></p>
<p class="p9"><span class="s2">    </span><span class="s1">return</span></p>
<p class="p9"><span class="s1">end</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p5"><span class="s7">local</span><span class="s1"> udp_port = ngx.</span><span class="s3">req</span><span class="s1">.</span><span class="s4">get_headers</span><span class="s1">()[</span><span class="s5">"param"</span><span class="s1">]</span></p>
<p class="p5"><span class="s7">if</span><span class="s1"> not udp_port </span><span class="s7">then</span></p>
<p class="p5"><span class="s1">    ngx.</span><span class="s4">log</span><span class="s1">(ngx.</span><span class="s3">ERR</span><span class="s1">, </span><span class="s5">"no param."</span><span class="s1">)</span></p>
<p class="p9"><span class="s2">    </span><span class="s1">return</span></p>
<p class="p9"><span class="s1">end</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">---- POINT BEFORE CONNECT ----</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- redis example.</span></p>
<p class="p7"><span class="s1">-- このままだと通信単位でredisアクセスが発生しちゃうので、このブロック内で、なんらかのtokenチェックをやるとかするとなお良い。このサーバにくるはずなら～とかそういう要素で。</span></p>
<p class="p9"><span class="s1">if</span><span class="s2"> </span><span class="s8">false</span><span class="s2"> </span><span class="s1">then</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">local</span><span class="s1"> redis = </span><span class="s4">require</span><span class="s1"> </span><span class="s5">"redis.redis"</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">local</span><span class="s1"> redisConn = redis:</span><span class="s4">new</span><span class="s1">()</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">local</span><span class="s1"> ok, err = redisConn:</span><span class="s4">connect</span><span class="s1">(</span><span class="s5">"127.0.0.1"</span><span class="s1">, </span><span class="s6">6379</span><span class="s1">)</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">    </span><span class="s7">if</span><span class="s1"> not ok </span><span class="s7">then</span></p>
<p class="p10"><span class="s2">        ngx.</span><span class="s4">log</span><span class="s2">(ngx.</span><span class="s3">ERR</span><span class="s2">, </span><span class="s1">"connection:"</span><span class="s2">, CONNECTION_ID, </span><span class="s1">" failed to generate redis client. err:"</span><span class="s2">, err)</span></p>
<p class="p5"><span class="s1">        </span><span class="s7">return</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">end</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s2">    </span><span class="s1">-- トークンをキーにして取得</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">local</span><span class="s1"> res, err = redisConn:</span><span class="s4">get</span><span class="s1">(token)</span></p>
<p class="p5"><span class="s1">    </span></p>
<p class="p7"><span class="s2">    </span><span class="s1">-- キーがkvsになかったら認証失敗として終了</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">if</span><span class="s1"> not res </span><span class="s7">then</span></p>
<p class="p7"><span class="s2">        </span><span class="s1">-- no key found.</span></p>
<p class="p10"><span class="s2">        ngx.</span><span class="s4">log</span><span class="s2">(ngx.</span><span class="s3">ERR</span><span class="s2">, </span><span class="s1">"connection:"</span><span class="s2">, CONNECTION_ID, </span><span class="s1">" failed to authenticate. no token found in kvs."</span><span class="s2">)</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">        </span><span class="s9">-- 切断</span></p>
<p class="p5"><span class="s1">        redisConn:</span><span class="s4">close</span><span class="s1">()</span></p>
<p class="p5"><span class="s1">        ngx.</span><span class="s4">exit</span><span class="s1">(</span><span class="s6">200</span><span class="s1">)</span></p>
<p class="p5"><span class="s1">        </span><span class="s7">return</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">elseif</span><span class="s1"> res == ngx.</span><span class="s3">null</span><span class="s1"> </span><span class="s7">then</span></p>
<p class="p7"><span class="s2">        </span><span class="s1">-- no value found.</span></p>
<p class="p10"><span class="s2">        ngx.</span><span class="s4">log</span><span class="s2">(ngx.</span><span class="s3">ERR</span><span class="s2">, </span><span class="s1">"connection:"</span><span class="s2">, CONNECTION_ID, </span><span class="s1">" failed to authenticate. token is nil."</span><span class="s2">)</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">        </span><span class="s9">-- 切断</span></p>
<p class="p5"><span class="s1">        redisConn:</span><span class="s4">close</span><span class="s1">()</span></p>
<p class="p5"><span class="s1">        ngx.</span><span class="s4">exit</span><span class="s1">(</span><span class="s6">200</span><span class="s1">)</span></p>
<p class="p5"><span class="s1">        </span><span class="s7">return</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">end</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s2">    </span><span class="s1">-- delete got key.</span></p>
<p class="p5"><span class="s1">    </span><span class="s7">local</span><span class="s1"> ok, err = redisConn:</span><span class="s4">del</span><span class="s1">(token)</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s2">    </span><span class="s1">-- 切断</span></p>
<p class="p5"><span class="s1">    redisConn:</span><span class="s4">close</span><span class="s1">()</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s2">    </span><span class="s1">-- 変数にセット、パラメータとして渡す。</span></p>
<p class="p5"><span class="s1">    user_data = res</span></p>
<p class="p9"><span class="s1">else</span></p>
<p class="p5"><span class="s1">    user_data = token</span></p>
<p class="p5"><span class="s1">    CONNECTION_ID = token</span></p>
<p class="p9"><span class="s1">end</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">-- ngx.log(ngx.ERR, "connection:", CONNECTION_ID, " user_data:", user_data)</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">---- CONNECT ----</span></p>
<p class="p5"><span class="s1">...</span></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p3"><b>go-udp-server</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>/goフォルダ以下に入っている。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>main.go(<a href="https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/go/main.go">https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/DockerResources/go/main.go</a>)</p>
<p class="p3"><span class="Apple-tab-span">	</span>をコンパイルして<span class="s10">起動しておく。</span></p>
<p class="p11"><span class="Apple-tab-span">	</span></p>
<p class="p12"><span class="Apple-tab-span">	</span>デフォルトでは8081ポートでudp接続を受け付け、tmp/<span class="s1">go-udp-serverという名前のunix domain socketを読み込む。</span></p>
<p class="p12"><span class="s1"><span class="Apple-tab-span">	</span>nginx stream機構の下で動くのを基礎としていて、nginxは8080/udpでudpを受け付け、8081 go-udp-serverへとデータをproxyする。</span></p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-tab-span">	</span>起動時にオプションを渡すことで、デフォルト設定を上書きすることができる。centosなどを使う際は適当に指定するといいと思う。</p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-tab-span">	</span>--portオプションでudpを待ち受けるポートを指定、</p>
<p class="p12"><span class="Apple-tab-span">	</span>--<span class="s1">domainオプションで、unix domain socketのパスを指定する。</span></p>
<p class="p11"><span class="s1"></span><br></p>
<p class="p12"><span class="s1"><span class="Apple-tab-span">	</span>負荷が高くなるとlua側で </span><span class="s11">shared connection is busy while proxying connection ログが出る。ただ、これが出る状態がすでにコア数に対してnginxのworkerがサチっている</span></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12"><b>disque</b></p>
<p class="p12"><span class="Apple-tab-span">	</span>disque-serverを別途起動しておく。</p>
<p class="p13"><span class="s10"><span class="Apple-tab-span">	</span>起動時に </span><span class="s12">--maxclients 100000 とかつけておくと、disqueのデフォルト値の10000以上の接続が可能になる。</span></p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-tab-span">	</span>luaから接続 -&gt; disque -&gt; upstreamへとデータを送り、</p>
<p class="p12"><span class="Apple-tab-span">	</span>upstream -&gt; disque -&gt; lua -&gt; クライアントへとデータを送る中継点に使われる。</p>
<p class="p11"><br></p>
<p class="p11"><span class="Apple-tab-span">	</span></p>
<p class="p14"><b>Upstream</b></p>
<p class="p12"><span class="Apple-tab-span">	</span>要はServer。</p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-tab-span">	</span>サンプルとして、約60fpsでクライアントへとechoを行うdotnet coreの機構を用意してある。</p>
<p class="p12"><span class="Apple-tab-span">	</span><a href="https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore/DockerResources/csharp">https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore/DockerResources/csharp</a></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12"><b>ログ</b></p>
<p class="p12"><span class="Apple-tab-span">	</span>接続、切断、エラーなどの基本的な情報は、すべてnginxのerror.logに出るようになっている。</p>
<p class="p12"><span class="Apple-tab-span">	</span>デフォルトでは切断時、エラー時のみログを出力している。</p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-tab-span">	</span>出力もとはluaなので、編集したい場合はそちらを。</p>
<p class="p11"><br></p>
<p class="p11"><b></b><br></p>
<p class="p12"><b>チューニング</b></p>
<p class="p12"><b><span class="Apple-tab-span">	</span>nginx error log</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; <span class="s11">max number of clients reached</span></p>
<p class="p12"><span class="s11"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> -&gt; disque</span>の<span class="s11">max connection設定を上回る接続がdisqueに来た。 デフォルトは10000、disqueを</span><span class="s13">--maxclients 100000とかつけて起動すればOK。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; too many なんちゃら、worker なんちゃら</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> -&gt; nginx.confにworker_rlimit_nofileやworker_connectionsの設定があるのでいじると良い。</span></p>
<p class="p3"><span class="s13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><b>Nginxのパフォーマンスを極限にするための考察</b></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><a href="https://qiita.com/iwai/items/1e29adbdd269380167d2">https://qiita.com/iwai/items/1e29adbdd269380167d2</a></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p17"><span class="s13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; </span><span class="s14">shared connection is busy while proxying connection</span></p>
<p class="p17"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> -&gt; luaからgo-udp-serverへとudpデータを送付する際に、nginx luaのソケットIOの限界を超えていると発生する。</span></p>
<p class="p18"><span class="s14"></span><br></p>
<p class="p18"><span class="s14"></span><br></p>
<p class="p17"><span class="s14"><b><span class="Apple-tab-span">	</span>クライアント側エラー</b></span></p>
<p class="p17"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; connection refused, reset by peer</span></p>
<p class="p17"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; サーバのtcp/ipのソケット数限界に達している可能性が高い。</span></p>
<p class="p17"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ubuntuだったら echo 1024 65535 &gt; /proc/sys/net/ipv4/ip_local_port_range とかでパラメータ変えればいい。</span></p>
<p class="p18"><span class="s14"></span><br></p>
<p class="p3"><span class="s15"><b><span class="Apple-tab-span">	</span></b></span><b>disquuun部分の負荷が高い</b></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; disquuunの初期化パラメータのコネクション数を増やすことで負荷が下がるケースがある。</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>60fps 10msg/sec up/down 5000接続以上で動く場合は、30接続くらいでいい予感がする。それ以上あげてもスペックが変わらない。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>また、各ユーザー向けのデータを送付時に各ユーザー単位でまとめると負荷が下がる。</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>理想は1fあたり各ユーザーに対して1通の送付にできるといい。</p>
<p class="p18"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p3"><span class="s15"><span class="Apple-tab-span">	</span></span><b>go-udp-serverの負荷が高い</b></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-&gt; 20~30%くらいはよくある感じ。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>メッセージ送付の数にそのまま関連するので、downstreamのメッセージ数を見直すと解消しやすい。</span></p>
<p class="p15"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b>各パーツの有無による負荷変動について</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>lua &lt;-&gt; disqueのメッセージのやり取りは、nginxのworkerへの負荷がわずかにある。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>これはworker数が多ければ多いほど各workerの負荷が減るので、スペックが伸びる。</span></p>
<p class="p13"><span class="s12"><span class="Apple-tab-span">	</span>4コアのマシンで </span><span class="s10">60fps 10msg/sec up/down を実施</span><span class="s12">させたところ、6000接続を超えたあたりからクライアントへのデータ送付がわずかに遅れるケースが散見された。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b><span class="Apple-tab-span">	</span>nginx workerに負荷がかかるとどうなるか</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>・クライアントへと届けるdownstreamが遅延する。ここが遅延するのは、各workerの負荷が40%とかを超えてから。worker数が多ければ避けられる。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>worker数を増やす、downstreamへのメッセージをまとめる、などで負荷が軽減できる。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b><span class="Apple-tab-span">	</span>disqueに負荷がかかるとどうなるか</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>・あまり問題が起こらない。メッセージの到達遅延につながったことはないっぽい。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>もし負荷が気になる場合、luaを改変してworkerごとに異なるdisqueにつながるようにするといいと思う。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b><span class="Apple-tab-span">	</span>upstreamに負荷がかかるとどうなるか</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>・全体のメッセージの流れが遅延する。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>upstreamのメッセージの吸い出しが遅くなり、</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>downstreamのメッセージの送付が遅くなる。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>メッセージの消化不良が溜まっていく以外に影響はでない。</span></p>
<p class="p15"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ただし、メッセージの消化不良が起こると、disqueがどんどんメモリを食っていくことになるので、</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>その辺に関して注意が必要。メッセージサイズが小さい + メッセージをまとめて扱うような工夫が効果が高い。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b><span class="Apple-tab-span">	</span>go-udp-serverに負荷がかかるとどうなるか</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>・あまり問題が起こらない。メッセージの到達遅延につながったことはないっぽい。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>負荷が気になる場合、新規にポートを指定してgo-udp-serverを追加し、nginx.confへとポート情報を加える。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>すると自動的に複数のgo-udp-serverへとデータが流れるため、負荷が分散できる。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><b>locust</b></span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>ベンチマークはlocustを使って行なっている。</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>使用しているlocust fileは、<a href="https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore/locust"><span class="s13">https://github.com/sassembla/nginx-luajit-ws/tree/benchmark-with-netcore/locust</span></a> に動作するものを置いてある。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>サンプルはDockerコンテナで動作するものになっていて、</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>ubuntuなどに放り込んで、rebuild.shを実行すれば起動、その後ポート8089にアクセスすれば接続と負荷掛けを実行できる。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>デフォルトで設定されている負荷は、</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>・1locustごとに1接続</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>・1locustにつき秒間10件程度のデータをサーバに送り、サーバから秒間10件程度のtcp + udpでのエコーを返す</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>・接続が確立されたり、切断されるとlocustのコンソールにメッセージやエラーが表示される</span></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>・データを受け取っていない場合のwarningとして、1秒以上データを受け取っていないクライアントにwarningが出る</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1"><span class="Apple-tab-span">	</span>変更すべき設定は、接続先のサーバのIPとport。</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">locusts.py(<a href="https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/locust/test/locusts.py"><span class="s13">https://github.com/sassembla/nginx-luajit-ws/blob/benchmark-with-netcore/locust/test/locusts.py</span></a>)</span></p>
<p class="p19"><span class="s1"><span class="Apple-converted-space">    </span>server_ip = </span><span class="s16">"150.95.211.59"</span></p>
<p class="p19"><span class="s1"><span class="Apple-converted-space">    </span># server_ip = </span><span class="s16">"127.0.0.1"</span></p>
<p class="p20"><span class="s1"></span><br></p>
<p class="p19"><span class="s1"><span class="Apple-converted-space">    </span>server_port = </span><span class="s17">8080</span></p>
<p class="p19"><span class="s1"><span class="Apple-converted-space">    </span>message_per_sec = </span><span class="s17">100.0</span><span class="s1"> / </span><span class="s17">1000.0</span></p>
<p class="p21"><span class="s18"><span class="Apple-converted-space">    </span>server_path = </span><span class="s1">"sample_disque_client"</span></p>
<p class="p22"><span class="s1"></span><br></p>
<p class="p23"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s12">server_ip、</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>server_port、</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>message_per_sec:メッセージを秒間何件クライアントから送付 -&gt; サーバから返送するか</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>この記述だと100.0 / 1000.0 = 0.1で、秒間10件送付する。名前間違えたな。。</span></p>
<p class="p25"><span class="s1"></span><br></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>server_path: url末尾につけられるパス。server_ip:server_port//<b>server_path</b> になる。</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span></span></p>
</body>
</html>
