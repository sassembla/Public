<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><link rel="stylesheet" type="text/less" href="../stylesheets/less/default.less"/><script type="text/javascript" src="../javascripts/less-1.3.0.min.js"></script>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1265.21">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 22.0px 'Hiragino Kaku Gothic ProN'}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic ProN'; min-height: 18.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic ProN'}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic ProN'; background-color: #ebebeb}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Hiragino Kaku Gothic ProN'; background-color: #ebebeb; min-height: 18.0px}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b><span class="Apple-converted-space"> </span>nginx + lua + webSocketでかんたんpub-subサーバ</b></p>
<p class="p2"><b></b><br></p>
<p class="p3"><b>概要</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>実験用に簡単に使えるWebSocketバックエンドが欲しかったので、</p>
<p class="p3"><span class="Apple-tab-span">	</span>ngx + ngx_lua_module からのゴリ押しで作ってみた。</p>
<p class="p2"><br></p>
<p class="p3"><b><span class="Apple-tab-span">	</span>sassembla / nginx-luajit-websocket-pubsuber</b></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><a href="https://github.com/sassembla/nginx-luajit-websocket-pubsuber">https://github.com/sassembla/nginx-luajit-websocket-pubsuber</a></p>
<p class="p2"><br></p>
<p class="p3"><b>構成</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx 1.7.10</p>
<p class="p3"><span class="Apple-tab-span">	</span>ngx_lua_module 0.9.15</p>
<p class="p3"><span class="Apple-tab-span">	</span>redis 2.8.9</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>luajit 2.1 alpha</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>websocket protocol + server</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>redis connector</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>other</p>
<p class="p2"><br></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p3"><b>動作内容</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginx-luaでは、リクエストごとに完璧にisolateされたluaスクリプト動作が発生する。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>たとえばWebSocket受ける場合、</p>
<p class="p3"><span class="Apple-tab-span">	</span>プロセスをwhileでがっちりブロックしてレスポンス返さずにWebSocket接続という形になった。</p>
<p class="p2"><br></p>
<p class="p3"><a href="https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L69">https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L69</a></p>
<p class="p4"><span class="Apple-tab-span">	</span>-- start websocket serving</p>
<p class="p4"><span class="Apple-tab-span">	</span>while true do</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>local recv_data, typ, err = wb:recv_frame()</p>
<p class="p5"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if wb.fatal then</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>local jsonData = json:encode({connectionId = serverId, state = STATE_DISCONNECT_1})</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>pubRedisCon:publish(IDENTIFIER_CENTRAL, jsonData)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>で、luaのコンテキストがリクエストごとにisolateされてるとは言っても、pub-subみたいなことをしたい場合、中継がなくて困るので、</p>
<p class="p3"><span class="Apple-tab-span">	</span>中継にredisのpubsubを使っている。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>redidのpubsubにpush性能は無く、こちらも単に、特定のキーのsubscribeをwhileループで行っている。</p>
<p class="p2"><br></p>
<p class="p3"><a href="https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L114">https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L114</a></p>
<p class="p4">-- subscribe loop</p>
<p class="p4">-- waiting data from central.</p>
<p class="p4">function subscribe ()</p>
<p class="p4"><span class="Apple-tab-span">	</span>while true do</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>local res, err = subRedisCon:read_reply()</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if not res then</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ngx.log(ngx.ERR, "redis subscribe read error:", err)</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>break</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>else</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-- for i,v in ipairs(res) do</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-- <span class="Apple-tab-span">	</span>ngx.log(ngx.ERR, "client i:", i, " v:", v)</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-- end</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>もちろん一個のリクエストプロセス中で2個while書けるはずなくて、ngx_lua_moduleから使えるthread生成を頼っている。</p>
<p class="p2"><br></p>
<p class="p3"><a href="https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L60">https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/client.lua#L60</a></p>
<p class="p4">function connectWebSocket()</p>
<p class="p4"><span class="Apple-tab-span">	</span>-- start subscribe</p>
<p class="p4"><span class="Apple-tab-span">	</span>ngx.thread.spawn(subscribe)</p>
<p class="p5"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>-- send connected</p>
<p class="p4"><span class="Apple-tab-span">	</span>local jsonData = json:encode({connectionId = serverId, state = STATE_CONNECT})</p>
<p class="p4"><span class="Apple-tab-span">	</span>pubRedisCon:publish(IDENTIFIER_CENTRAL, jsonData)</p>
<p class="p5"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>-- start websocket serving</p>
<p class="p4"><span class="Apple-tab-span">	</span>while true do</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>local recv_data, typ, err = wb:recv_frame()</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>中央部分と残念なとこ</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>redisでpubsubを使って、client x n -&gt; central, central -&gt; client x n を繋いでいる。</p>
<p class="p3"><span class="Apple-tab-span">	</span>つまりredisのpubsubが2系統ある。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>で、clientはWebSocket接続なわけだが、centralは、</p>
<p class="p3"><span class="Apple-tab-span">	</span>httpで通信してきたプロセスをredisのcentral pubsubのためにガッチリ拘束する、っていう残念な方法を取っている。</p>
<p class="p2"><br></p>
<p class="p3"><a href="https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/controlpoint.lua#L99">https://github.com/sassembla/nginx-luajit/blob/master/bin/lua/controlpoint.lua#L99</a></p>
<p class="p4">function main ()</p>
<p class="p4"><span class="Apple-tab-span">	</span>-- start waiting loop</p>
<p class="p4"><span class="Apple-tab-span">	</span>while true do</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>local res, err = subRedisCon:read_reply()</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if not res then</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ngx.log(ngx.ERR, "failed to receiving data from clients, err:", err)</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ngx.exit(500)</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>else</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>つまり現在の構造は、以下の順でしか動作できない。</p>
<p class="p3"><span class="Apple-tab-span">	</span>1.httpでcentralのパスにアクセス(この通信は帰ってこない)</p>
<p class="p3"><span class="Apple-tab-span">	</span>2.適当にWebSocket接続</p>
<p class="p3"><span class="Apple-tab-span">	</span>3.中央コンテキストでいろいろできる</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p3"><span class="Apple-tab-span">	</span>httpで通信してきただけのやつを停めるのどうなの？　とか、それ起動時に自動的にできないの？ とか、そのへんを模索しているところ。</p>
<p class="p2"><br></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p3"><b>副産物</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>期せずしてredisのpub subに依存したが、これによってclient側へのpushの責務がclient connection側に一任されていて、</p>
<p class="p3"><span class="Apple-tab-span">	</span>送付確認周りをわりと疎結合かつ非同期に作る事が出来た。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>つまり一対多のWebSocketのsendにロックがかかっていない。</p>
<p class="p3"><span class="Apple-tab-span">	</span>使っててちょっと楽だ。実用に耐えるとは思ってないけど。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>また、redisでの中継でclients - centralを繋いでいるので、clientsからどのpubsubを使うか指定させる事でルームみたいな概念が実現できた。</p>
<p class="p3"><span class="Apple-tab-span">	</span>なかなかおもしろい。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>ロックせず、各自のwhileループで回っている部分自体はまあはいって感じなんだけど、redisのpubsubによってタイムラグは若干出ると思う。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>client側の実装として、udp版やmqtt版みたいなのも作ってみたい。</p>
<p class="p3"><span class="Apple-tab-span">	</span>まあキューイング部分が全部redisに寄るので、あっさり破綻すると思うけど。</p>
<p class="p3"><span class="Apple-tab-span">	</span>中間にRabbitMQとかくっつけるのが正しい気がする。</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p3"><b>エラー処理について</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>clientは、エラーが起こった瞬間subscribeをヤメて自沈する。</p>
<p class="p3"><span class="Apple-tab-span">	</span>というかぶっちゃけredisについて詳しく知らないので、何がどうなってるのかコード追ったりしてみようと思う。</p>
<p class="p2"><br></p>
<p class="p3"><span class="Apple-tab-span">	</span>良く出来てるソフトウェアが多くて助かる。</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>とりあえず動かせたので</b></p>
<p class="p3"><span class="Apple-tab-span">	</span>nginxのモジュール書くか、</p>
<p class="p3"><span class="Apple-tab-span">	</span>コンセプトモデルだけこれでOKということにしてnginxを基礎にした別物をCでガンガン書くか、</p>
<p class="p3"><span class="Apple-tab-span">	</span>何もかもなかったことにしてコンセプトをnginxから学びつつgoで遊ぶかの3択中。</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p3"><span class="Apple-tab-span">	</span>ngx_lua、楽しいです。</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
</body>
</html>
